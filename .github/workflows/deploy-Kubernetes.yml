name: 🚀 Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: "Environnement cible (dev/staging/production)"
        required: true
        type: string
      image-tag:
        description: "Tag de l'image Docker"
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  detect-structure:
    name: 🔍 Detect Project Structure
    runs-on: ubuntu-latest
    outputs:
      is-parent: ${{ steps.detect.outputs.is-parent }}
      microservices: ${{ steps.detect.outputs.microservices }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔍 Detect structure
        id: detect
        run: |
          if [ -d "microservices" ]; then
            echo "is-parent=true" >> $GITHUB_OUTPUT
            MS_LIST=$(ls -d microservices/*/ 2>/dev/null | xargs -n 1 basename | jq -R -s -c 'split("\n")[:-1]')
            echo "microservices=$MS_LIST" >> $GITHUB_OUTPUT
            echo "🔍 Structure PARENT détectée"
          else
            echo "is-parent=false" >> $GITHUB_OUTPUT
            echo "microservices=[\".\"]" >> $GITHUB_OUTPUT
            echo "🔍 Structure MICROSERVICE détectée"
          fi

  deploy-parent:
    name: 🚀 Deploy ${{ matrix.microservice }} to ${{ inputs.environment }}
    needs: detect-structure
    if: needs.detect-structure.outputs.is-parent == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
    strategy:
      fail-fast: false
      matrix:
        microservice: ${{ fromJson(needs.detect-structure.outputs.microservices) }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: 🔧 Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: 🔐 Configure Kubernetes credentials
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl cluster-info

      - name: 📋 Déterminer le namespace
        id: namespace
        run: |
          case "${{ inputs.environment }}" in
            production) NAMESPACE="prod" ;;
            staging) NAMESPACE="staging" ;;
            dev) NAMESPACE="dev" ;;
            *) NAMESPACE="dev" ;;
          esac
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT

      - name: 📦 Vérifier/Créer namespace
        run: |
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"
          if ! kubectl get namespace $NAMESPACE &> /dev/null; then
            kubectl create namespace $NAMESPACE
          fi

      - name: 🔐 Create Image Pull Secret
        run: |
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --namespace=$NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: 🚀 Deploy with Helm
        working-directory: helm-charts/microservice-template
        run: |
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"
          IMAGE_TAG="${{ inputs.image-tag }}"
          MICROSERVICE="${{ matrix.microservice }}"
          VALUES_FILE="values-${{ inputs.environment }}.yaml"
          
          if [ ! -f "$VALUES_FILE" ]; then
            VALUES_FILE="values.yaml"
          fi
          
          helm upgrade --install $MICROSERVICE . \
            --namespace $NAMESPACE \
            --create-namespace \
            --values $VALUES_FILE \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$MICROSERVICE \
            --set image.tag=$IMAGE_TAG \
            --set nameOverride=$MICROSERVICE \
            --set fullnameOverride=$MICROSERVICE \
            --wait \
            --timeout 5m

      - name: 🔍 Vérifier le déploiement
        run: |
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"
          MICROSERVICE="${{ matrix.microservice }}"
          kubectl wait --for=condition=ready pod -l app=$MICROSERVICE --namespace=$NAMESPACE --timeout=300s
          kubectl get pods -n $NAMESPACE -l app=$MICROSERVICE

      - name: 💾 Save deployment info
        run: |
          NAMESPACE="${{ steps.namespace.outputs.namespace }}"
          MICROSERVICE="${{ matrix.microservice }}"
          
          # Sauvegarder les infos pour les tests d'intégration
          mkdir -p deployment-info
          
          SERVICE_NAME=$(kubectl get svc -n $NAMESPACE -l app=$MICROSERVICE -o jsonpath='{.items[0].metadata.name}')
          SERVICE_PORT=$(kubectl get svc -n $NAMESPACE -l app=$MICROSERVICE -o jsonpath='{.items[0].spec.ports[0].port}')
          
          cat > deployment-info/$MICROSERVICE.json <<EOF
          {
            "microservice": "$MICROSERVICE",
            "namespace": "$NAMESPACE",
            "service_name": "$SERVICE_NAME",
            "service_port": "$SERVICE_PORT",
            "image_tag": "${{ inputs.image-tag }}"
          }
          EOF

      - name: 📤 Upload deployment info
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info-${{ matrix.microservice }}
          path: deployment-info/${{ matrix.microservice }}.json
          retention-days: 1

  deploy-microservice:
    name: 🚀 Deploy to ${{ inputs.environment }}
    needs: detect-structure
    if: needs.detect-structure.outputs.is-parent == 'false'
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: 🔧 Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: 🔐 Configure Kubernetes credentials
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl cluster-info

      - name: 📋 Déterminer le namespace et app name
        id: config
        run: |
          case "${{ inputs.environment }}" in
            production) NAMESPACE="prod" ;;
            staging) NAMESPACE="staging" ;;
            dev) NAMESPACE="dev" ;;
            *) NAMESPACE="dev" ;;
          esac
          
          # Extraire le nom depuis pom.xml
          APP_NAME=$(mvn help:evaluate -Dexpression=project.artifactId -q -DforceStdout 2>/dev/null || echo "application")
          
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
          echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT

      - name: 📦 Vérifier/Créer namespace
        run: |
          NAMESPACE="${{ steps.config.outputs.namespace }}"
          if ! kubectl get namespace $NAMESPACE &> /dev/null; then
            kubectl create namespace $NAMESPACE
          fi

      - name: 🔐 Create Image Pull Secret
        run: |
          NAMESPACE="${{ steps.config.outputs.namespace }}"
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --namespace=$NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: 🚀 Deploy with Helm
        working-directory: helm-charts
        run: |
          NAMESPACE="${{ steps.config.outputs.namespace }}"
          APP_NAME="${{ steps.config.outputs.app_name }}"
          IMAGE_TAG="${{ inputs.image-tag }}"
          
          # Chercher le dossier helm (peut être microservice-template ou autre)
          if [ -d "microservice-template" ]; then
            cd microservice-template
          elif [ -d "$APP_NAME" ]; then
            cd "$APP_NAME"
          else
            cd $(ls -d */ | head -n 1)
          fi
          
          VALUES_FILE="values-${{ inputs.environment }}.yaml"
          if [ ! -f "$VALUES_FILE" ]; then
            VALUES_FILE="values.yaml"
          fi
          
          helm upgrade --install $APP_NAME . \
            --namespace $NAMESPACE \
            --create-namespace \
            --values $VALUES_FILE \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=$IMAGE_TAG \
            --set nameOverride=$APP_NAME \
            --set fullnameOverride=$APP_NAME \
            --wait \
            --timeout 5m

      - name: 🔍 Vérifier le déploiement
        run: |
          NAMESPACE="${{ steps.config.outputs.namespace }}"
          APP_NAME="${{ steps.config.outputs.app_name }}"
          kubectl wait --for=condition=ready pod -l app=$APP_NAME --namespace=$NAMESPACE --timeout=300s
          kubectl get pods -n $NAMESPACE -l app=$APP_NAME

      - name: 💾 Save deployment info
        run: |
          NAMESPACE="${{ steps.config.outputs.namespace }}"
          APP_NAME="${{ steps.config.outputs.app_name }}"
          
          # Sauvegarder les infos pour les tests d'intégration
          mkdir -p deployment-info
          
          SERVICE_NAME=$(kubectl get svc -n $NAMESPACE -l app=$APP_NAME -o jsonpath='{.items[0].metadata.name}')
          SERVICE_PORT=$(kubectl get svc -n $NAMESPACE -l app=$APP_NAME -o jsonpath='{.items[0].spec.ports[0].port}')
          
          cat > deployment-info/app.json <<EOF
          {
            "application": "$APP_NAME",
            "namespace": "$NAMESPACE",
            "service_name": "$SERVICE_NAME",
            "service_port": "$SERVICE_PORT",
            "image_tag": "${{ inputs.image-tag }}"
          }
          EOF

      - name: 📤 Upload deployment info
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: deployment-info/app.json
          retention-days: 1
